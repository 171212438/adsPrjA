/**
 * \file IfxPmsEvr.h
 * \brief PMS basic functionality
 * \ingroup IfxLld_Pms
 *
 * \version iLLD_1_0_1_17_0
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Pms_Std_Evr EVR
 * \ingroup IfxLld_Pms_Std
 * \defgroup IfxLld_Pms_Std_Evr_Enum Enumerations
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_Over-Voltage Over Voltage Functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_Module Module Functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_Under-Voltage Under Voltage Functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_EVRC EVRC Functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_EVR33 EVR33 Functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_SWD SWD Functions
 * \ingroup IfxLld_Pms_Std_Evr
 */

#ifndef IFXPMSEVR_H
#define IFXPMSEVR_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxPms_cfg.h"
#include "Cpu/Std/IfxCpu.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "IfxPms_bf.h"
#include "IfxPms_reg.h"
#include "IfxStm_reg.h"
#include "IfxScu_reg.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

#define IFXPMSEVR_ADC_VDD_LSB               (0.005f)

#define IFXPMSEVR_ADC_VDDP3_LSB             (0.015f)

#define IFXPMSEVR_ADC_VEXT_LSB              (0.02f)

#define IFXPMSEVR_CTRL_UP_WAIT_TIMEOUTCOUNT (0x100)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pms_Std_Evr_Enum
 * \{ */
/** \brief Configure respective interrupts define in register Ifx_PMS.PMSIEN
 */
typedef enum
{  // 电源管理芯片-电压调节器的各种中断源
    IfxPmsEvr_EnableInterrupt_ovswd = 0,   /**< 过压中断 */
    IfxPmsEvr_EnableInterrupt_uvswd = 1,   /**< 欠压中断 */
    IfxPmsEvr_EnableInterrupt_ov33 = 2,   /**< 3.3V电源过压中断 */
    IfxPmsEvr_EnableInterrupt_uv33 = 3,   /**< 3.3V电源欠压中断 */
    IfxPmsEvr_EnableInterrupt_ovc = 4,   /**< 核心电源过压 */
    IfxPmsEvr_EnableInterrupt_uvc = 5,   /**< 核心电源欠压 */
    IfxPmsEvr_EnableInterrupt_ovpre = 6,   /**< 预稳压器过压 */
    IfxPmsEvr_EnableInterrupt_uvpre = 7,   /**< 预稳压器欠压 */
    IfxPmsEvr_EnableInterrupt_ovddm = 8,   /**< 数字域模块过压 */
    IfxPmsEvr_EnableInterrupt_uvddm = 9,   /**< 欠压 */
    IfxPmsEvr_EnableInterrupt_ovsb = 10,  /**< Standby备用域过压 */
    IfxPmsEvr_EnableInterrupt_uvsb = 11,  /**< 欠压 */
    IfxPmsEvr_EnableInterrupt_evrcmod = 16,  /**<  EVR控制模式变更中断*/
    IfxPmsEvr_EnableInterrupt_sdvok = 17,  /**< 降压稳压器就绪中断 */
    IfxPmsEvr_EnableInterrupt_synclck = 18,  /**< 同步时钟中断 */
    IfxPmsEvr_EnableInterrupt_swdlvl = 19,  /**< 稳压器电压级别改变中断 */
    IfxPmsEvr_EnableInterrupt_wutwkp = 21,  /**< 唤醒定时器中断 */
    IfxPmsEvr_EnableInterrupt_esr0wkp = 22,  /**< ESR0紧急停止信号唤醒中断 */
    IfxPmsEvr_EnableInterrupt_esr1wkp = 23,  /**< ESR1紧急停止信号唤醒中断 */
    IfxPmsEvr_EnableInterrupt_pinawkp = 24,  /**< 外部引脚A唤醒中断 */
    IfxPmsEvr_EnableInterrupt_pinbwkp = 25,  /**< B */
    IfxPmsEvr_EnableInterrupt_scrint = 26,  /**< SRC中断 */
    IfxPmsEvr_EnableInterrupt_scrrst = 27,  /**< SRC复位中断 */
    IfxPmsEvr_EnableInterrupt_screcc = 28,  /**< SRC ECC错误中断 */
    IfxPmsEvr_EnableInterrupt_scrwdt = 29   /**< SRC看门狗中断 */
} IfxPmsEvr_EnableInterrupt;

/** \brief Current operation mode of EVRC Regulator defined in Ifx_PMS.EVR.STAT.B.EVRCMOD
 */
typedef enum
{  // 定义稳压器当前工作模式
    IfxPmsEvr_EvrcMode_pwmMode = 0,  /**< PWM模式,  正常模式 */
    IfxPmsEvr_EvrcMode_lowPowerMode = 1,  /**< 低功耗模式 */
    IfxPmsEvr_EvrcMode_startupMode = 2,  /**< 启动模式 */
    IfxPmsEvr_EvrcMode_disableMode = 3   /**< 禁用模式 */
} IfxPmsEvr_EvrcMode;

/** \brief Switching frequency division factor for external synchronisation defined in Ifx_PMS.EVRSDCTRL7.B.SYNCDIVFAC
 */
typedef enum
{  // 稳压器外部同步开关频率的分频系数
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_1 = 0,  /**< 无分频 */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_2 = 1,  /**< 2分频 */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_4 = 2,  /**< 4分频 */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_8 = 3,  /**< 8 */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_16 = 4,  /**< 16 */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_32 = 5   /**< 32 */
} IfxPmsEvr_ExtSyncSwitchingFreqDivFactor;

/** \brief Monitoring OverVoltage for all bitfields defined
 * in .Ifx_PMS.EVR.MONCTRL register for overvoltage monitoring
 */
typedef enum
{  // 定义过压监控模式
    IfxPmsEvr_OverVoltageMonitoring_inactive = 0, /**< 不监测 */
    IfxPmsEvr_OverVoltageMonitoring_lowToHighVoltageTransition = 1, /**< 从低于阈值变为高于阈值时产生过压事件 */
    IfxPmsEvr_OverVoltageMonitoring_highToLowVoltageTransition = 2, /**< 高 -> 低时产生过压事件 */
    IfxPmsEvr_OverVoltageMonitoring_eitherDirectionVoltageTransition = 3  /**< 穿过阈值时产生过压事件 */
} IfxPmsEvr_OverVoltageMonitoring;

/** \brief set TRIM Value For respective Voltages.
 * Defined in Ifx_PMS.EVR.TRIM and Ifx_PMS.EVR.TRIM2
 */
typedef enum
{  // 定义PMS EVR的主ADC校准值, 从0到63; ADC校准指对模拟数字转换器的基准值进行微调, 以提高ADC精度, 值越大调整的强度越高; 建议初始阶段使用默认
    IfxPmsEvr_PrimaryAdcTrimValue_0 = 0,      /**< \brief Primary Adc Trim Value 0  */
    IfxPmsEvr_PrimaryAdcTrimValue_1,          /**< \brief Primary Adc Trim Value 1  */
    IfxPmsEvr_PrimaryAdcTrimValue_2,          /**< \brief Primary Adc Trim Value 2  */
    IfxPmsEvr_PrimaryAdcTrimValue_3,          /**< \brief Primary Adc Trim Value 3  */
    IfxPmsEvr_PrimaryAdcTrimValue_4,          /**< \brief Primary Adc Trim Value 4  */
    IfxPmsEvr_PrimaryAdcTrimValue_5,          /**< \brief Primary Adc Trim Value 5  */
    IfxPmsEvr_PrimaryAdcTrimValue_6,          /**< \brief Primary Adc Trim Value 6  */
    IfxPmsEvr_PrimaryAdcTrimValue_7,          /**< \brief Primary Adc Trim Value 7  */
    IfxPmsEvr_PrimaryAdcTrimValue_8,          /**< \brief Primary Adc Trim Value 8  */
    IfxPmsEvr_PrimaryAdcTrimValue_9,          /**< \brief Primary Adc Trim Value 9  */
    IfxPmsEvr_PrimaryAdcTrimValue_10,         /**< \brief Primary Adc Trim Value 10  */
    IfxPmsEvr_PrimaryAdcTrimValue_11,         /**< \brief Primary Adc Trim Value 11  */
    IfxPmsEvr_PrimaryAdcTrimValue_12,         /**< \brief Primary Adc Trim Value 12  */
    IfxPmsEvr_PrimaryAdcTrimValue_13,         /**< \brief Primary Adc Trim Value 13  */
    IfxPmsEvr_PrimaryAdcTrimValue_14,         /**< \brief Primary Adc Trim Value 14  */
    IfxPmsEvr_PrimaryAdcTrimValue_15,         /**< \brief Primary Adc Trim Value 15  */
    IfxPmsEvr_PrimaryAdcTrimValue_16,         /**< \brief Primary Adc Trim Value 16  */
    IfxPmsEvr_PrimaryAdcTrimValue_17,         /**< \brief Primary Adc Trim Value 17  */
    IfxPmsEvr_PrimaryAdcTrimValue_18,         /**< \brief Primary Adc Trim Value 18  */
    IfxPmsEvr_PrimaryAdcTrimValue_19,         /**< \brief Primary Adc Trim Value 19  */
    IfxPmsEvr_PrimaryAdcTrimValue_20,         /**< \brief Primary Adc Trim Value 20  */
    IfxPmsEvr_PrimaryAdcTrimValue_21,         /**< \brief Primary Adc Trim Value 21  */
    IfxPmsEvr_PrimaryAdcTrimValue_22,         /**< \brief Primary Adc Trim Value 22  */
    IfxPmsEvr_PrimaryAdcTrimValue_23,         /**< \brief Primary Adc Trim Value 23  */
    IfxPmsEvr_PrimaryAdcTrimValue_24,         /**< \brief Primary Adc Trim Value 24  */
    IfxPmsEvr_PrimaryAdcTrimValue_25,         /**< \brief Primary Adc Trim Value 25  */
    IfxPmsEvr_PrimaryAdcTrimValue_26,         /**< \brief Primary Adc Trim Value 26  */
    IfxPmsEvr_PrimaryAdcTrimValue_27,         /**< \brief Primary Adc Trim Value 27  */
    IfxPmsEvr_PrimaryAdcTrimValue_28,         /**< \brief Primary Adc Trim Value 28  */
    IfxPmsEvr_PrimaryAdcTrimValue_29,         /**< \brief Primary Adc Trim Value 29  */
    IfxPmsEvr_PrimaryAdcTrimValue_30,         /**< \brief Primary Adc Trim Value 30  */
    IfxPmsEvr_PrimaryAdcTrimValue_31,         /**< \brief Primary Adc Trim Value 31  */
    IfxPmsEvr_PrimaryAdcTrimValue_32,         /**< \brief Primary Adc Trim Value 32  */
    IfxPmsEvr_PrimaryAdcTrimValue_33,         /**< \brief Primary Adc Trim Value 33  */
    IfxPmsEvr_PrimaryAdcTrimValue_34,         /**< \brief Primary Adc Trim Value 34  */
    IfxPmsEvr_PrimaryAdcTrimValue_35,         /**< \brief Primary Adc Trim Value 35  */
    IfxPmsEvr_PrimaryAdcTrimValue_36,         /**< \brief Primary Adc Trim Value 36  */
    IfxPmsEvr_PrimaryAdcTrimValue_37,         /**< \brief Primary Adc Trim Value 37  */
    IfxPmsEvr_PrimaryAdcTrimValue_38,         /**< \brief Primary Adc Trim Value 38  */
    IfxPmsEvr_PrimaryAdcTrimValue_39,         /**< \brief Primary Adc Trim Value 39  */
    IfxPmsEvr_PrimaryAdcTrimValue_40,         /**< \brief Primary Adc Trim Value 40  */
    IfxPmsEvr_PrimaryAdcTrimValue_41,         /**< \brief Primary Adc Trim Value 41  */
    IfxPmsEvr_PrimaryAdcTrimValue_42,         /**< \brief Primary Adc Trim Value 42  */
    IfxPmsEvr_PrimaryAdcTrimValue_43,         /**< \brief Primary Adc Trim Value 43  */
    IfxPmsEvr_PrimaryAdcTrimValue_44,         /**< \brief Primary Adc Trim Value 44  */
    IfxPmsEvr_PrimaryAdcTrimValue_45,         /**< \brief Primary Adc Trim Value 45  */
    IfxPmsEvr_PrimaryAdcTrimValue_46,         /**< \brief Primary Adc Trim Value 46  */
    IfxPmsEvr_PrimaryAdcTrimValue_47,         /**< \brief Primary Adc Trim Value 47  */
    IfxPmsEvr_PrimaryAdcTrimValue_48,         /**< \brief Primary Adc Trim Value 48  */
    IfxPmsEvr_PrimaryAdcTrimValue_49,         /**< \brief Primary Adc Trim Value 49  */
    IfxPmsEvr_PrimaryAdcTrimValue_50,         /**< \brief Primary Adc Trim Value 50  */
    IfxPmsEvr_PrimaryAdcTrimValue_51,         /**< \brief Primary Adc Trim Value 51  */
    IfxPmsEvr_PrimaryAdcTrimValue_52,         /**< \brief Primary Adc Trim Value 52  */
    IfxPmsEvr_PrimaryAdcTrimValue_53,         /**< \brief Primary Adc Trim Value 53  */
    IfxPmsEvr_PrimaryAdcTrimValue_54,         /**< \brief Primary Adc Trim Value 54  */
    IfxPmsEvr_PrimaryAdcTrimValue_55,         /**< \brief Primary Adc Trim Value 55  */
    IfxPmsEvr_PrimaryAdcTrimValue_56,         /**< \brief Primary Adc Trim Value 56  */
    IfxPmsEvr_PrimaryAdcTrimValue_57,         /**< \brief Primary Adc Trim Value 57  */
    IfxPmsEvr_PrimaryAdcTrimValue_58,         /**< \brief Primary Adc Trim Value 58  */
    IfxPmsEvr_PrimaryAdcTrimValue_59,         /**< \brief Primary Adc Trim Value 59  */
    IfxPmsEvr_PrimaryAdcTrimValue_60,         /**< \brief Primary Adc Trim Value 60  */
    IfxPmsEvr_PrimaryAdcTrimValue_61,         /**< \brief Primary Adc Trim Value 61  */
    IfxPmsEvr_PrimaryAdcTrimValue_62,         /**< \brief Primary Adc Trim Value 62  */
    IfxPmsEvr_PrimaryAdcTrimValue_63          /**< \brief Primary Adc Trim Value 63  */
} IfxPmsEvr_PrimaryAdcTrimValue;

/** \brief This Declare the Under and overvoltage counter defined in Ifx_PMS.EVR.MONFILT.B.ERRCNTLIMT
 */
typedef enum
{  // 定义次级电压错误计数器的阈值, 电压错误累计达到多少次后触发相关报警或中断
    IfxPmsEvr_SecondaryVoltageErrorCounter_level0 = 0,      /**< \brief Error Counter Limit 0  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level1,          /**< \brief Error Counter Limit 1  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level2,          /**< \brief Error Counter Limit 2  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level3,          /**< \brief Error Counter Limit 3  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level4,          /**< \brief Error Counter Limit 4  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level5,          /**< \brief Error Counter Limit 5  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level6,          /**< \brief Error Counter Limit 6  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level7,          /**< \brief Error Counter Limit 7  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level8,          /**< \brief Error Counter Limit 8  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level9,          /**< \brief Error Counter Limit 9  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level10,         /**< \brief Error Counter Limit 10  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level11,         /**< \brief Error Counter Limit 11  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level12,         /**< \brief Error Counter Limit 12  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level13,         /**< \brief Error Counter Limit 13  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level14,         /**< \brief Error Counter Limit 14  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level15,         /**< \brief Error Counter Limit 15  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level16,         /**< \brief Error Counter Limit 16  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level17,         /**< \brief Error Counter Limit 17  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level18,         /**< \brief Error Counter Limit 18  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level19,         /**< \brief Error Counter Limit 19  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level20,         /**< \brief Error Counter Limit 20  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level21,         /**< \brief Error Counter Limit 21  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level22,         /**< \brief Error Counter Limit 22  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level23,         /**< \brief Error Counter Limit 23  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level24,         /**< \brief Error Counter Limit 24  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level25,         /**< \brief Error Counter Limit 25  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level26,         /**< \brief Error Counter Limit 26  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level27,         /**< \brief Error Counter Limit 27  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level28,         /**< \brief Error Counter Limit 28  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level29,         /**< \brief Error Counter Limit 29  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level30,         /**< \brief Error Counter Limit 30  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level31,         /**< \brief Error Counter Limit 31  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level32,         /**< \brief Error Counter Limit 32  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level33,         /**< \brief Error Counter Limit 33  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level34,         /**< \brief Error Counter Limit 34  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level35,         /**< \brief Error Counter Limit 35  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level36,         /**< \brief Error Counter Limit 36  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level37,         /**< \brief Error Counter Limit 37  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level38,         /**< \brief Error Counter Limit 38  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level39,         /**< \brief Error Counter Limit 39  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level40,         /**< \brief Error Counter Limit 40  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level41,         /**< \brief Error Counter Limit 41  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level42,         /**< \brief Error Counter Limit 42  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level43,         /**< \brief Error Counter Limit 43  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level44,         /**< \brief Error Counter Limit 44  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level45,         /**< \brief Error Counter Limit 45  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level46,         /**< \brief Error Counter Limit 46  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level47,         /**< \brief Error Counter Limit 47  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level48,         /**< \brief Error Counter Limit 48  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level49,         /**< \brief Error Counter Limit 49  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level50,         /**< \brief Error Counter Limit 50  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level51,         /**< \brief Error Counter Limit 51  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level52,         /**< \brief Error Counter Limit 52  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level53,         /**< \brief Error Counter Limit 53  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level54,         /**< \brief Error Counter Limit 54  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level55,         /**< \brief Error Counter Limit 55  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level56,         /**< \brief Error Counter Limit 56  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level57,         /**< \brief Error Counter Limit 57  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level58,         /**< \brief Error Counter Limit 58  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level59,         /**< \brief Error Counter Limit 59  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level60,         /**< \brief Error Counter Limit 60  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level61,         /**< \brief Error Counter Limit 61  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level62,         /**< \brief Error Counter Limit 62  */
    IfxPmsEvr_SecondaryVoltageErrorCounter_level63          /**< \brief Error Counter Limit 63  */
} IfxPmsEvr_SecondaryVoltageErrorCounter;

/** \brief ADC result for the generating Alarm declare in Ifx_PMS.EVR.MONFILT
 */
typedef enum
{  // 电源电源监控ADC结果的滤波方式; 单次测量: 每次ADC转换的结果直接与阈值进行比较; 移动平均滤波: 基于连续多次的ADC转换结果计算移动平均值, 再进行比较, 以降低误报率
    IfxPmsEvr_SupplyFilter_eachConversionResult = 0,    /**< \brief Each conversion result is compared with threshold to generate alarm */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult0 = 1,    /**< \brief A moving mean average of consecutive 0 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult1,        /**< \brief A moving mean average of consecutive 1 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult2,        /**< \brief A moving mean average of consecutive 2 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult3,        /**< 连续3次ADC结果的移动平均值  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult4,        /**< \brief A moving mean average of consecutive 4 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult5,        /**< \brief A moving mean average of consecutive 5 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult6,        /**< \brief A moving mean average of consecutive 6 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult7,        /**< \brief A moving mean average of consecutive 7 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult8,        /**< \brief A moving mean average of consecutive 8 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult9,        /**< \brief A moving mean average of consecutive 9 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult10,       /**< \brief A moving mean average of consecutive 10 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult11,       /**< \brief A moving mean average of consecutive 11 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult12,       /**< \brief A moving mean average of consecutive 12 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult13,       /**< \brief A moving mean average of consecutive 13 ADC results  */
    IfxPmsEvr_SupplyFilter_avgAdcConversionResult14        /**< 最大程度的滤波, 延迟较高, 稳定性较佳  */
} IfxPmsEvr_SupplyFilter;

/** \brief Controls the voltage supply Type
 */
typedef enum
{  // 电源管理系统中所支持的各类电压供应模式或类型
    IfxPmsEvr_SupplyMode_evrc = 0,  /**< 内置电压稳压控制模式 */
    IfxPmsEvr_SupplyMode_evr33 = 1,  /**< 内部3.3V稳压器或VDDP3外部供电线路 */
    IfxPmsEvr_SupplyMode_swd = 2,  /**< 外部供电线路并配合供电监控看门狗功能 */
    IfxPmsEvr_SupplyMode_evrpr = 3,  /**< 内部预稳压器或外部VDDPD供电线路 */
    IfxPmsEvr_SupplyMode_vddm = 4,  /**< ADC模块的专用电源 */
    IfxPmsEvr_SupplyMode_sb = 5   /**< 备用电压供应模式, 多用于待机或低功耗状态 */
} IfxPmsEvr_SupplyMode;

/** \brief Monitoring underVoltage for all bitfields defined
 * in Ifx_PMS.EVR.MONCTRL register for undervoltage monitoring
 */
typedef enum
{  // 欠压监控事件的触发条件
    IfxPmsEvr_UnderVoltageMonitoring_inactive = 0, /**< 不监控 */
    IfxPmsEvr_UnderVoltageMonitoring_lowToHighVoltageTransition = 1, /**< 低与阈值向高于阈值过渡时报警 */
    IfxPmsEvr_UnderVoltageMonitoring_highToLowVoltageTransition = 2, /**< \brief Under-Voltage event is generated when threshold is crossed in higher to lower voltage transition */
    IfxPmsEvr_UnderVoltageMonitoring_eitherDirectionVoltageTransition = 3  /**< 双向 */
} IfxPmsEvr_UnderVoltageMonitoring;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

typedef struct
{  // 定义电源管理系统-电压调节寄存器的配置
    volatile void *regAddr;       /**寄存器地址 */
    uint32 value;         /**写入寄存器的值 */
    uint32 mask;          /**寄存器中具体需要更新的位域 */
} IfxPmsEvr_StepDownRegulatorRegConfig;

typedef struct
{  // 初始化过程的一个阶段
    uint8 numOfRegisters;  // 要配置的寄存器个数
    IFX_CONST IfxPmsEvr_StepDownRegulatorRegConfig *regConfig;  // 本阶段具体要配置的寄存器数组
    float32 waitInSecs;  // 执行完本阶段配置后, 要等待的时间(秒)
} IfxPmsEvr_initSequencePhase;

typedef struct
{  // 检查PMS EVR配置是否符合期望
    uint8 numOfRegisters;  // 要检查的寄存器个数
    IFX_CONST IfxPmsEvr_StepDownRegulatorRegConfig *regConfig;  // 要验证的寄存器配置数组
} IfxPmsEvr_checkRegConfig;

typedef struct
{  // 完整描述PMS EVR初始化过程
    uint8 numOfPhases;  // 初始化过程中的阶段数量
    IFX_CONST IfxPmsEvr_initSequencePhase *phaseConfig;  // 指向初始化阶段数组, 每阶段可能包括一系列寄存器配置和相应等待周期
} IfxPmsEvr_initSequence;

/** \addtogroup IfxLld_Pms_Std_Evr_Over-Voltage
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------主要用于配置和管理芯片的PMS中的EVR模块*/
/******************************************************************************/

/** \brief set Over Voltage Monitoring Mode
 * \param pms pointer to the Module space
 * \param mode specifies the monitoring mode
 * \param supply select EVRC,EVR33,VDDM,SWD or SB supply
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setOverVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_OverVoltageMonitoring mode, IfxPmsEvr_SupplyMode supply);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief set Secondary Over Voltage Threshold level
 * \param pms Pointer to PMS Module
 * \param thresholdLevel over-voltage monitoring threshold level of the respective
 * regulator output or supply
 * \param supply select EVRC,EVR33,SWD,EVRPR,VDDM or SB supply mode
 * \return None
 */
IFX_EXTERN void IfxPmsEvr_setSecondaryOverVoltageThresholdMv(Ifx_PMS *pms, float32 thresholdLevel, IfxPmsEvr_SupplyMode supply);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_Module
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configure a Blanking Filter Delay
 * \param pms Pointer To PMS Module
 * \param delay Blanking Filter Delay in ms
 * \return None
 */
IFX_INLINE void IfxPmsEvr_configureBlankingFilterDelay(Ifx_PMS *pms, uint8 delay);

/** \brief This function enables the synchronisation output to synchronize the external
 * SMPS regulator with respect to the internal EVRC regulator
 * \param pms Pointer to PMS Module
 * \param enabled enable/disable DC-DC synchronisation
 * \return None
 */
IFX_INLINE void IfxPmsEvr_enableDcdcSynchronisation(Ifx_PMS *pms, boolean enabled);

/** \brief Enable Interrupts
 * \param pms Pointer to PMS Module
 * \param interruptType Select The Interrupt Type
 * \return None
 */
IFX_INLINE void IfxPmsEvr_enableInterrupts(Ifx_PMS *pms, IfxPmsEvr_EnableInterrupt interruptType);

/** \brief enables wakeup on VEXT supply ramp-up after blanking filter
 * time has expired
 * \param pms Pointer To PMS Module
 * \param enabled Wake-up Enable on VEXT Supply ramp-up
 * \return None
 */
IFX_INLINE void IfxPmsEvr_enableWakeupOnVextSupplyRampUp(Ifx_PMS *pms, boolean enabled);

/** \brief OSC Fine Trim 100MHz Clock
 * \param pms pointer to PMS Module
 * \param trimValue OSC fine trim value
 * \return None
 */
IFX_INLINE void IfxPmsEvr_fineTrimEvrClock(Ifx_PMS *pms, uint8 trimValue);

/** \brief set frequency spread threshold
 * \param pms pointer to PMS module
 * \param thresholdLevel maximum frequency spreading value
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setFrequencySpreadThreshold(Ifx_PMS *pms, uint16 thresholdLevel);

/** \brief This configures the state of N ch. MOSFET driver during start-up and
 * shut-down phases
 * \param pms Pointer to PMS Module
 * \param nmosLevel TRISTATE/LOW
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setNmosLevel(Ifx_PMS *pms, boolean nmosLevel);

/** \brief This configures the state of P ch. MOSFET driver during start-up and
 * shut-down phases
 * \param pms Pointer to PMS Module
 * \param pmosLevel TRISTATE/LOW
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setPmosLevel(Ifx_PMS *pms, boolean pmosLevel);

/** \brief set regulator switching frequency in Hz....(100MHz/samplingFactor)
 * \param pms Pointer to PMS Module
 * \param samplingFactor Over-sampling Factor
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setRegulatorSwitchingFrequency(Ifx_PMS *pms, uint16 samplingFactor);

/** \brief set reset trim value for EVRC,EVR33 and external VEXT supply
 * \param pms Pointer to PMS Module Space
 * \param resetTrimValue Reset Trim Value
 * \param supply select EVRC,EVR33 regulator or external VEXT supply watchdog
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setResetTrimValueMv(Ifx_PMS *pms, float32 resetTrimValue, IfxPmsEvr_SupplyMode supply);

/** \brief SD Regulator Voltage Target selection
 * \param pms Pointer to PMS Module
 * \param outputLevel The VDD output level of the Step down regulator
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setSdRegulatorOutputLevel(Ifx_PMS *pms, uint8 outputLevel);

/** \brief SD Regulator Voltage Trim Value
 * \param pms Pointer to PMS Moule Space
 * \param trimValue offset added to the VDD output level
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setSdRegulatorPrimaryAdcTrimValue(Ifx_PMS *pms, IfxPmsEvr_PrimaryAdcTrimValue trimValue);

/** \brief set DLMU RAM Block in Standby Mode
 * \param pms Pointer To PMS Module
 * \param ramBlock DLMU RAM block
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setStandbyRamSupply(Ifx_PMS *pms, uint8 ramBlock);

/** \brief Set Switching frequency division factor for external synchronisation.
 * \param pms Pointer To PMS Module
 * \param divider Switching frequency division factor for external synchronisation
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setSwitchingFreqDivFactorForExternalsync(Ifx_PMS *pms, IfxPmsEvr_ExtSyncSwitchingFreqDivFactor divider);

/** \brief OSC Fine Trim 100MHz Clock
 * \param pms Pointer to PMS Module
 * \param trimValue OSC Signed fine trim value
 * \return None
 */
IFX_INLINE void IfxPmsEvr_signedFineTrimEvrClock(Ifx_PMS *pms, sint8 trimValue);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief filter the each conversion result or avarage of consecutive adc result to compare with threshold
 * \param pms Pointer to PMS Module
 * \param adcFilterValue specify average of consecutive ADC results
 * \param supply select EVRC,EVR33,SWD,EVRPR,VDDM or SB supply mode
 * \return None
 */
IFX_EXTERN void IfxPmsEvr_filterSecondaryConversionResult(Ifx_PMS *pms, IfxPmsEvr_SupplyFilter adcFilterValue, IfxPmsEvr_SupplyMode supply);

/** \brief get secondray ADC result for respective Voltage supply
 * \param pms Pointer To PMS Module
 * \param supply select EVRC,EVR33,SWD,EVRPR,VDDM or SB supply mode
 * \return last conversion result of the ADC measurement
 * of respective voltage by secondary monitor
 */
IFX_EXTERN uint8 IfxPmsEvr_getSecondaryAdcResult(Ifx_PMS *pms, IfxPmsEvr_SupplyMode supply);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_Under-Voltage
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief set Under Voltage Monitoring mode
 * \param pms Pointer to the PMS Module space
 * \param mode specifies the monitoring mode
 * \param supply select EVRC,EVR33,VDDM,SWD or SB supply
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setUnderVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_UnderVoltageMonitoring mode, IfxPmsEvr_SupplyMode supply);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief set Secondary under Voltage Threshold level
 * \param pms Pointer to PMS Module space
 * \param thresholdLevel under-voltage monitoring threshold level of the respective
 * regulator output or supply
 * \param supply select EVRC,EVR33,SWD,EVRPR,VDDM or SB supply mode
 * \return None
 */
IFX_EXTERN void IfxPmsEvr_setSecondaryUnderVoltageThresholdMv(Ifx_PMS *pms, float32 thresholdLevel, IfxPmsEvr_SupplyMode supply);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_EVRC
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enabled/Disable Reset Trigger signal for EVRC
 * \param pms pointer to PMS Module
 * \param enableReset Enable/Disable the reset trigger signal
 * \return None
 */
IFX_INLINE void IfxPmsEvr_evrcResetTriggerSignalConfig(Ifx_PMS *pms, boolean enableReset);

/**
 * \param averageADCC Average value of PMS_EVRADCSTAT.ADCCV.
 * \return ADC VDD Core Voltage Conversion Result
 */
IFX_INLINE float32 IfxPmsEvr_getAdcVddResult(float32 averageADCC);

/** \brief get current operating mode of EVRC
 * \param pms Pointer to PMS Module Space
 * \return EVRC Mode
 */
IFX_INLINE IfxPmsEvr_EvrcMode IfxPmsEvr_getEvrcMode(Ifx_PMS *pms);

/** \brief get EVRC Regulator Voltage status
 * \param pms Pointer to PMS Module Space
 * \return EVRC Regulator Voltage OK status
 */
IFX_INLINE boolean IfxPmsEvr_getEvrcVoltageRegulator(Ifx_PMS *pms);

/** \brief get ADC 1.25 V Core Voltage Conversion Result
 * \param pms Pointer to PMS Module space
 * \return last conversion result of the ADC measurement of
 * the VDD / EVRC supply by the Primary Monitor
 */
IFX_INLINE uint8 IfxPmsEvr_getPrimaryAdcEvrcResult(Ifx_PMS *pms);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_EVR33
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enabled/Disable Reset Trigger signal for EVR33
 * \param pms pointer to PMS Module
 * \param enableReset Enable/Disable the reset trigger signal
 * \return None
 */
IFX_INLINE void IfxPmsEvr_evr33ResetTriggerSignalConfig(Ifx_PMS *pms, boolean enableReset);

/** \brief get ADC 3.3 V Voltage Conversion Result
 * \param pms Pointer to PMS Module Space
 * \return last conversion result of the ADC measurement of
 * the VDDP3 / EVR33 supply by the Primary Monitor
 */
IFX_INLINE uint8 IfxPmsEvr_getPrimaryAdcEvr33Result(Ifx_PMS *pms);

/** \brief set 3.3 V Regulator Voltage Primary ADC Trim Value
 * \param pms Pointer to PMS Module
 * \param trimValue Trimming value offeset added to Output level
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setEvr33PrimaryAdcTrimValue(Ifx_PMS *pms, IfxPmsEvr_PrimaryAdcTrimValue trimValue);

/** \brief The VDDP3 output level of the EVR33 LDO regulator
 * \param pms Pointer to PMS Module
 * \param outputLevel define VDDP3 output level of the EVR33 LDO regulator.
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setEvr33VoltageOutputlevel(Ifx_PMS *pms, uint8 outputLevel);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_SWD
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief get ADC External Supply Conversion Result
 * \param pms Pointer to PMS Module space
 * \return last conversion result of the ADC measurement of
 * the external VEXT (3.3V / 5V) supply by the Primary Monitor
 */
IFX_INLINE uint8 IfxPmsEvr_getPrimaryAdcSwdResult(Ifx_PMS *pms);

/** \brief Enabled/Disable Reset Trigger signal for SWD
 * \param pms Pointer to PMS Module
 * \param enableReset Enable/Disable the reset trigger signal
 * \return None
 */
IFX_INLINE void IfxPmsEvr_swdResetTriggerSignalConfig(Ifx_PMS *pms, boolean enableReset);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 */
IFX_INLINE boolean IfxPmsEvr_areInitValuesRight(const IfxPmsEvr_checkRegConfig *const checkConfig);

/** \brief Disable Interrupts
 * \return None
 */
IFX_INLINE void IfxPmsEvr_disableInterrupt(Ifx_PMS *pms, IfxPmsEvr_EnableInterrupt interruptType);

/**
 * \param averageADC33V Average of PMS_EVRSTAT.ADC33V values
 * \return ADC VDDP3 Voltage Conversion Result
 */
IFX_INLINE float32 IfxPmsEvr_getAdcVddp3Result(float32 averageADC33V);

/**
 * \param averageADCSWDV Average of PMS_EVRADCSTAT.ADCSWDV values.
 * \return ADC VEXT Supply Conversion Result
 */
IFX_INLINE float32 IfxPmsEvr_getAdcVextResult(float32 averageADCSWDV);

/**
 */
IFX_INLINE boolean IfxPmsEvr_runInitSequence(const IfxPmsEvr_initSequence *const sequence);

/**
 * \return None
 */
IFX_INLINE void IfxPmsEvr_wait(float32 waitInSec);

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/
IFX_EXTERN IFX_CONST IfxPmsEvr_StepDownRegulatorRegConfig IfxPmsEvr_cfgPhase1Default[];

IFX_EXTERN IFX_CONST IfxPmsEvr_StepDownRegulatorRegConfig IfxPmsEvr_cfgPhase2Default[];

/** \brief
 */
IFX_EXTERN IFX_CONST IfxPmsEvr_StepDownRegulatorRegConfig IfxPmsEvr_cfgPhase3Default[];

IFX_EXTERN IFX_CONST IfxPmsEvr_initSequencePhase IfxPmsEvr_cfgPhasesDefault[];

IFX_EXTERN IFX_CONST IfxPmsEvr_initSequence IfxPmsEvr_cfgSequenceDefault;

IFX_EXTERN IFX_CONST IfxPmsEvr_checkRegConfig IfxPmsEvr_checkRegCfgDefault;

IFX_EXTERN IFX_CONST IfxPmsEvr_StepDownRegulatorRegConfig IfxPmsEvr_checkRegValuesDefault[];

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE boolean IfxPmsEvr_areInitValuesRight(const IfxPmsEvr_checkRegConfig *const checkConfig)
{  // 检查EVR寄存器的实际配置与预期是否一致
    boolean allRight = TRUE;
    sint32 regCfgCount;

    if (PMS_EVRSTAT.B.EVRC == 1U)
    {
        for (regCfgCount = 0; regCfgCount < checkConfig->numOfRegisters; regCfgCount++)
        {
            uint32 regVal;
            const IfxPmsEvr_StepDownRegulatorRegConfig *regConfig = &checkConfig->regConfig[regCfgCount];
            regVal = (*((volatile uint32 *)regConfig->regAddr));
            regVal &= regConfig->mask;

            if (regVal != regConfig->value)
            {
                allRight = FALSE;
            }
        }

        /*Check if EVRSTAT.SDVOK is set*/
        if (allRight == TRUE)
        {
            if (PMS_EVRSTAT.B.SDVOK != 1)
            {
                allRight = FALSE;
            }
        }
    }

    return allRight;
}


IFX_INLINE void IfxPmsEvr_configureBlankingFilterDelay(Ifx_PMS *pms, uint8 delay)
{  // 配置电压监控的空白滤波延迟事件
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->PMSWCR0.B.BLNKFIL = delay;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_disableInterrupt(Ifx_PMS *pms, IfxPmsEvr_EnableInterrupt interruptType)
{  // 禁用指定类型的EVR中断事件
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    uint32 mask = (1U << interruptType);
    pms->PMSIEN.U &= (~mask);

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_enableDcdcSynchronisation(Ifx_PMS *pms, boolean enabled)
{  // 开启或关闭与外部DC-CD转换器的同步输出, 确保外部开关电源与内部EVRC稳压器频率协调一致
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->PMSWCR5.B.DCDCSYNCO = enabled;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_enableInterrupts(Ifx_PMS *pms, IfxPmsEvr_EnableInterrupt interruptType)
{  // 启用指定类型的EVR相关中断事件
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->PMSIEN.U |= (1U << interruptType);

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_enableWakeupOnVextSupplyRampUp(Ifx_PMS *pms, boolean enabled)
{  // 外部供电(VEXT)启动电压达到一定阈值时, 使能唤醒功能
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->PMSWCR0.B.PWRWKEN = enabled;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_evr33ResetTriggerSignalConfig(Ifx_PMS *pms, boolean enableReset)
{  // 启用或禁用ERV33电压异常的复位触发信号
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVRRSTCON.B.BPRST33OFF = 1;
    pms->EVRRSTCON.B.RST33OFF = enableReset;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_evrcResetTriggerSignalConfig(Ifx_PMS *pms, boolean enableReset)
{  // 启用或禁用EVRC电压异常复位触发信号
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVRRSTCON.B.BPRSTCOFF = 1;
    pms->EVRRSTCON.B.RSTCOFF = enableReset;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_fineTrimEvrClock(Ifx_PMS *pms, uint8 trimValue)
{  // 精细校准EVR内部的100MHz时钟
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVROSCCTRL.B.OSCFTRIM = trimValue;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE float32 IfxPmsEvr_getAdcVddResult(float32 averageADCC)
{  // 将EVRC核心电压ADC平均值转换位实际电压值
    float32 vddVoltage = 0;
    vddVoltage = (IFXPMSEVR_ADC_VDD_LSB * averageADCC + 0.7125f);
    return vddVoltage;
}


IFX_INLINE float32 IfxPmsEvr_getAdcVddp3Result(float32 averageADC33V)
{  // 将3.3V电压ADC测量平均值转换位实际电压值
    float32 vddp3Voltage = 0;
    vddp3Voltage = (IFXPMSEVR_ADC_VDDP3_LSB * averageADC33V + 0.9375f);
    return vddp3Voltage;
}


IFX_INLINE float32 IfxPmsEvr_getAdcVextResult(float32 averageADCSWDV)
{  // 将外部供电ADC测量平均值转换为实际电压值
    float32 vextVoltage = 0;
    vextVoltage = (IFXPMSEVR_ADC_VEXT_LSB * averageADCSWDV + 1.050f);
    return vextVoltage;
}


IFX_INLINE IfxPmsEvr_EvrcMode IfxPmsEvr_getEvrcMode(Ifx_PMS *pms)
{  // 获取EVRC稳压器当前运行模式
    return (IfxPmsEvr_EvrcMode)pms->EVRSTAT.B.EVRCMOD;
}


IFX_INLINE boolean IfxPmsEvr_getEvrcVoltageRegulator(Ifx_PMS *pms)
{  // 查询EVRC稳压器电压是否正常
    return (boolean)pms->EVRSTAT.B.SDVOK;
}


IFX_INLINE uint8 IfxPmsEvr_getPrimaryAdcEvr33Result(Ifx_PMS *pms)
{  // 获取EVR33的主ADC测量结果
    return pms->EVRADCSTAT.B.ADC33V;
}


IFX_INLINE uint8 IfxPmsEvr_getPrimaryAdcEvrcResult(Ifx_PMS *pms)
{  // 获取EVRC的主ADC监测最新测量结果
    return pms->EVRADCSTAT.B.ADCCV;
}


IFX_INLINE uint8 IfxPmsEvr_getPrimaryAdcSwdResult(Ifx_PMS *pms)
{  // 获取外部供电主ADC测量结果
    return pms->EVRADCSTAT.B.ADCSWDV;
}


#if defined(__TASKING__)
#pragma optimize L
#elif defined(__HIGHTEC__)
#pragma GCC optimize ("-O2")
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma GCC optimize ("-O2")
#endif
IFX_INLINE boolean IfxPmsEvr_runInitSequence(const IfxPmsEvr_initSequence *const sequence)
{  // 按指定序列执行EVR初始化步骤
    boolean pmsInitDone = TRUE;
    uint32 regVal;
    uint16 endinitSfty_pw = IfxScuWdt_getGlobalSafetyEndinitPasswordInline();
    const IfxPmsEvr_initSequencePhase *phaseConfig;
    const IfxPmsEvr_StepDownRegulatorRegConfig *regConfig;

    if (PMS_EVRSTAT.B.EVRC == 1U)
    {
        /*Loop through each configured phase*/
        for (phaseConfig = &sequence->phaseConfig[0];
             phaseConfig < &sequence->phaseConfig[sequence->numOfPhases];
             phaseConfig++)
        {
            IfxScuWdt_clearGlobalSafetyEndinitInline(endinitSfty_pw);

            /*Loop through each register which is configured in the phase configuration*/
            for (regConfig = &phaseConfig->regConfig[0];
                 regConfig < &phaseConfig->regConfig[phaseConfig->numOfRegisters];
                 regConfig++)
            {
                regVal = (*((volatile uint32 *)regConfig->regAddr));
                regVal &= ~regConfig->mask;
                regVal |= regConfig->value;

                /** During normal running one must wait for the LCK bit.
                 * However, for this function, as this is used only with CPU0 startup no wait required
                 */
                (*((volatile uint32 *)regConfig->regAddr)) = regVal; /*Write to the physical register*/
            }

            PMS_EVRSDCTRL0.B.UP = 1;
            IfxScuWdt_setGlobalSafetyEndinitInline(endinitSfty_pw);

            /* wait for the UP bit*/
            sint32 timeoutCount = IFXPMSEVR_CTRL_UP_WAIT_TIMEOUTCOUNT;

            /*Now, wait for the UP bit at EVRSDCTRL0 is reset, which is to indicate the configurations are done*/
            do
            {
                if (--timeoutCount <= 0)
                {
                    pmsInitDone = FALSE;
                    break;
                }
            } while (PMS_EVRSDCTRL0.B.UP == 1);

            IfxPmsEvr_wait(phaseConfig->waitInSecs);        // wait for configured time
        }
    }

    /*return the status*/
    return pmsInitDone;
}
#if defined(__TASKING__)
#pragma endoptimize
#elif defined(__HIGHTEC__)
#pragma GCC reset_options
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma GCC reset_options
#endif


IFX_INLINE void IfxPmsEvr_setEvr33PrimaryAdcTrimValue(Ifx_PMS *pms, IfxPmsEvr_PrimaryAdcTrimValue trimValue)
{  // 配置EVR33稳压器的主ADC微调值, 精细调整输出电压精度
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVRTRIM.B.EVR33VOUTTRIM = trimValue;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_setEvr33VoltageOutputlevel(Ifx_PMS *pms, uint8 outputLevel)
{  // 设定EVR33稳压器目标输出电压等级
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVRTRIM.B.EVR33VOUTSEL = outputLevel;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_setFrequencySpreadThreshold(Ifx_PMS *pms, uint16 thresholdLevel)
{  // 设定EVR开关频率的扩频阈值, 以减少电池干扰EMI
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVRSDCTRL0.B.SDFREQSPRD = thresholdLevel;
    pms->EVRSDCTRL0.B.UP = 1;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_setNmosLevel(Ifx_PMS *pms, boolean nmosLevel)
{  // 在EVR启动和关闭阶段设置N沟道MOSFET驱动的输出状态
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVRSDCTRL0.B.NGOFF = nmosLevel;
    pms->EVRSDCTRL0.B.UP = 1;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_setOverVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_OverVoltageMonitoring mode, IfxPmsEvr_SupplyMode supply)
{  // 该函数用于配置EVR(电压调节器)模块的过压监测模式, 指定何种电压过渡条件会触发过压事件报警或保护动作
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    Ifx_PMS_MONCTRL tempMONCTRL;
    IfxScuWdt_clearSafetyEndinit(passwd);
    tempMONCTRL.U = pms->MONCTRL.U;

    switch (supply)
    {
    case IfxPmsEvr_SupplyMode_evrc:
        tempMONCTRL.B.EVRCOVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_evr33:
        tempMONCTRL.B.EVR33OVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_swd:
        tempMONCTRL.B.SWDOVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_evrpr:
        tempMONCTRL.B.PREOVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_vddm:
        tempMONCTRL.B.VDDMOVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_sb:
        tempMONCTRL.B.SBOVMOD = mode;
        break;
    }

    pms->MONCTRL.U = tempMONCTRL.U;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_setPmosLevel(Ifx_PMS *pms, boolean pmosLevel)
{  // 在EVR启动和关闭阶段设置P沟道MOSFET驱动的输出状态
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVRSDCTRL0.B.PGOFF = pmosLevel;
    pms->EVRSDCTRL0.B.UP = 1;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_setRegulatorSwitchingFrequency(Ifx_PMS *pms, uint16 samplingFactor)
{  // 设置EVR稳压器的开关频率 100MHz/samplingFactor
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVRSDCTRL0.B.SDFREQ = samplingFactor;
    pms->EVRSDCTRL0.B.UP = 1;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_setResetTrimValueMv(Ifx_PMS *pms, float32 resetTrimValue, IfxPmsEvr_SupplyMode supply)
{  // 为芯片的EVR(电压调节器)模块或外部VEXT供电, 配置复位触发电压的微调值
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    Ifx_PMS_EVRRSTCON tempRSTCON;
    IfxScuWdt_clearSafetyEndinit(passwd);
    tempRSTCON.U = pms->EVRRSTCON.U;

    switch (supply)
    {
    case IfxPmsEvr_SupplyMode_evrc:
        tempRSTCON.B.RSTCTRIM = ((resetTrimValue - 712.5f) / 5);
        break;
    case IfxPmsEvr_SupplyMode_evr33:
        tempRSTCON.B.RST33TRIM = ((resetTrimValue - 937.5f) / 15);
        break;
    case IfxPmsEvr_SupplyMode_swd:
        tempRSTCON.B.RSTSWDTRIM = ((resetTrimValue - 1050) / 20);
        break;
    default:
        break;
    }

    pms->EVRRSTCON.U = tempRSTCON.U;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_setSdRegulatorOutputLevel(Ifx_PMS *pms, uint8 outputLevel)
{  // 配置降压稳压器目标输出电压等级
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->EVRTRIM.B.SDVOUTSEL = outputLevel;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_setSdRegulatorPrimaryAdcTrimValue(Ifx_PMS *pms, IfxPmsEvr_PrimaryAdcTrimValue trimValue)
{  // 设定降压稳压器SD的主ADC校准值, 以精细调整稳压器输出
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVRTRIM.B.SDVOUTTRIM = trimValue;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_setStandbyRamSupply(Ifx_PMS *pms, uint8 ramBlock)
{  // 待机模式下的DLMU RAM区块供电配置电压, 以维持待机状态RAM数据保存
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);

    pms->PMSWCR0.B.STBYRAMSEL = ramBlock;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_setSwitchingFreqDivFactorForExternalsync(Ifx_PMS *pms, IfxPmsEvr_ExtSyncSwitchingFreqDivFactor divider)
{  // 配置EVR开关频率对外部同步信号的分频系数
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVRSDCTRL7.B.SYNCDIVFAC = divider;
    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_setUnderVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_UnderVoltageMonitoring mode, IfxPmsEvr_SupplyMode supply)
{  // 配置欠压监测模式(不激活, 低到高电压过渡, 高到低电压过渡, 双向)
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
    Ifx_PMS_MONCTRL tempMONCTRL;
    IfxScuWdt_clearSafetyEndinit(passwd);
    tempMONCTRL.U = pms->MONCTRL.U;

    switch (supply)
    {
    case IfxPmsEvr_SupplyMode_evrc:
        tempMONCTRL.B.EVRCUVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_evr33:
        tempMONCTRL.B.EVR33UVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_swd:
        tempMONCTRL.B.SWDUVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_evrpr:
        tempMONCTRL.B.PREUVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_vddm:
        tempMONCTRL.B.VDDMUVMOD = mode;
        break;
    case IfxPmsEvr_SupplyMode_sb:
        tempMONCTRL.B.SBUVMOD = mode;
        break;
    }

    pms->MONCTRL.U = tempMONCTRL.U;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_signedFineTrimEvrClock(Ifx_PMS *pms, sint8 trimValue)
{  // 使用带符号数值更精细调整EVR内部100MHz时钟
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVROSCCTRL.B.OSCFPTRIM = trimValue;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_swdResetTriggerSignalConfig(Ifx_PMS *pms, boolean enableReset)
{  // 启用或禁用外部供电的电压异常复位触发信号
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearSafetyEndinit(passwd);
    pms->EVRRSTCON.B.BPRSTSWDOFF = 1;
    pms->EVRRSTCON.B.RSTSWDOFF = enableReset;

    IfxScuWdt_setSafetyEndinit(passwd);
}


IFX_INLINE void IfxPmsEvr_wait(float32 waitInSec)
{  // 执行延时等待, 以确保配置稳定生效
    uint32 stmCount = (uint32)((float32)33000000UL * waitInSec);
    uint32 stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
    {
        /* There is no need to check overflow of the STM timer.
         * When counter after overflow subtracted with counter before overflow,
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}


#endif /* IFXPMSEVR_H */
