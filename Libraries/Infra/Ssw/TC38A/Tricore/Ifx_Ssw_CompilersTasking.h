/**
 * \file Ifx_Ssw_CompilersTasking.h
 * \brief Startup Software for Tasking compiler options
 *
 * \version iLLD_1_0_1_17_0
 * \copyright Copyright (c) 2018 Infineon Technologies AG. All rights reserved.
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
#ifndef IFX_SSW_COMPILERSTASKING_H_
#define IFX_SSW_COMPILERSTASKING_H_

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/*Linker definitions which are specific to Tasking */
/* IFX_CFG_USE_COMPILER_DEFAULT_LINKER shall be defined in Ifx_Cfg.h
 * to use the default compiler linker varaibles and startup */
#ifndef IFX_CFG_USE_COMPILER_DEFAULT_LINKER

/*Start: Common definitions ********************************************** */
#define IFX_SSW_COMMON_LINKER_SYMBOLS()                                     \
    __asm("\t .extern _SMALL_DATA_, _LITERAL_DATA_, _A8_DATA_, _A9_DATA_");  /**小数据段(A0相对寻址)的起始地址, 常量段(A1相对寻址)的起始地址, 快速访问数据(A8, A9相对寻址)的起始地址*/\
    extern unsigned int __START0[];     /**< CPU0启动代码地址指针 */ \
    extern unsigned int __START1[];     /**< Pointer to the CPU1 startup code */ \
    extern unsigned int __START2[];     /**< Pointer to the CPU2 startup code */ \
    extern unsigned int __START3[];     /**< Pointer to the CPU3 startup code */ \
    extern unsigned int __START4[];     /**< Pointer to the CPU4 startup code */ \
    extern unsigned int __START5[];     /**< Pointer to the CPU5 startup code */

/*End: Common definitions ************************************************ */

/*Start: Core 0 definitions ********************************************** */

/*C extern defintions */
#define IFX_SSW_CORE_LINKER_SYMBOLS(cpu)  /**< 必须与链接脚本中符号定义匹配一致 */\
    __asm("\t .extern __USTACK"#cpu);  /**< 用户栈的栈底地址, 用于系统启动汇编代码 */ \
    extern unsigned int __ISTACK##cpu[];  /**< 中断栈的栈底地址 */ \
    extern unsigned int __INTTAB_CPU##cpu[];  /**< 中断向量表的起始地址 */ \
    extern unsigned int __TRAPTAB_CPU##cpu[];  /**< 异常向量表的起始地址 */ \
    extern unsigned int __CSA##cpu[];  /**< 上下文保存区起始地址 */ \
    extern unsigned int __CSA##cpu##_END[];  /**< 上下文保存区结束地址 */

#define __USTACK(cpu)      __USTACK##cpu
#define __ISTACK(cpu)      __ISTACK##cpu
#define __INTTAB_CPU(cpu)  __INTTAB_CPU##cpu
#define __TRAPTAB_CPU(cpu) __TRAPTAB_CPU##cpu
#define __CSA(cpu)         __CSA##cpu
#define __CSA_END(cpu)     __CSA##cpu##_END
#define __START(cpu)       __START##cpu

/*Wrapper macros for the tool specific definitions */
#if defined(IFX_USE_SW_MANAGED_INT)
#define __INTTAB(cpu)      ((unsigned int)__INTTAB_CPU##cpu | (unsigned int)0x1FE0)
#else
#define __INTTAB(cpu)      __INTTAB_CPU##cpu
#endif /*defined(IFX_USE_SW_MANAGED_INT) */

#define __TRAPTAB(cpu)     __TRAPTAB_CPU##cpu

#define __SDATA1(cpu)      _SMALL_DATA_
#define __SDATA2(cpu)      _LITERAL_DATA_
#define __SDATA3(cpu)      _A8_DATA_
#define __SDATA4(cpu)      _A9_DATA_

#endif /*IFX_CFG_USE_COMPILER_DEFAULT_LINKER*/

#ifdef __cplusplus
#define IFX_SSW_INLINE   static inline
#else
#define IFX_SSW_INLINE   inline
#endif

#define IFX_SSW_NULL_PTR ((void *)0x0U)  // 明确表示一个未执行有效内存区域的指针

#define IFX_SSW_WEAK     __attribute__ ((weak))  // 使用GCC扩展属性weak, 定义了弱链接符号, 标记为weak的函数或变量可被用户提供的同名符号覆盖

/******************************************************************************/
/*----------------------------   GNU Intrinsics  -----------------------------*/
/******************************************************************************/

#define Ifx_Ssw_MTCR(reg, val) __mtcr(reg, val);  // 将值val写入核心特殊功能寄存器reg

#define Ifx_Ssw_MFCR(reg)      __mfcr(reg);  // 从核心特殊功能寄存器reg取值

IFX_SSW_INLINE void Ifx_Ssw_NOP(void)
{
    __nop();  // 什么都不做, 仅消耗一个时钟周期
}


IFX_SSW_INLINE void Ifx_Ssw_DSYNC(void)  // 内存访问、外设寄存器写入后, 确保数据已真正生效再继续执行后续指令
{
    __dsync();  // 执行数据同步指令, 确保之前所有数据存储指令执行完成后再继续
}


IFX_SSW_INLINE void Ifx_Ssw_ISYNC(void)  // CPU控制寄存器修改或跳转指令执行后, 确保新状态或跳转立即生效
{
    __isync();  // 执行指令同步指令, 刷新CPU流水线
}


IFX_SSW_INLINE unsigned int Ifx_Ssw_MINU(unsigned int a, unsigned int b)
{
    return __minu(a, b);  // 返回两个无符号整数中较小的一个值, 效率高于一般C的实现
}


#define Ifx_Ssw_CLZ(a)                     __clz(a)  // 快速确定某个位字段的最高有效位位置, 优化位操作算法, 快速数值计算和和算法优化

// TriCore架构要求通过两步完成32位绝对地址的加载操作, movh.a加载高16位, lea加载低16位
#define Ifx_Ssw___setAddressReg(aReg, val) \
    {__asm(" movh.a\t "#aReg ",#@his("#val ")\n lea\t "#aReg ",["#aReg "]@los("#val ")"); }

#define Ifx_Ssw_setAddressReg(regNum, val) Ifx_Ssw___setAddressReg(regNum, val)

IFX_SSW_INLINE void Ifx_Ssw_moveToDataParam0(unsigned int var)
{
    __asm("mov d2, %0" ::"d" (var));  // 将一个32位无符号整数var加载到数据寄存器d2中, d告诉编译器使用数据寄存器进行数据传递
}


IFX_SSW_INLINE unsigned int Ifx_Ssw_getDataParam0(void)
{
    unsigned int var;
    __asm(" mov\t %0, d2" : "=d" (var));  // 从数据寄存器d2中读取32位无符号整数并返回, =d表示输出变量使用数据寄存器接收
    return var;
}


IFX_SSW_INLINE void Ifx_Ssw_jumpToFunction(void *fun)
{
    __asm("ji %0" ::"a" (fun));  // 跳转到函数地址fun执行
}


IFX_SSW_INLINE void Ifx_Ssw_jumpToFunctionWithLink(void *fun)
{
    __asm("jli %0" ::"a" (fun));  // Jump and Link Indexed, 跳转到函数指针fun指定的地址, 并保存返回的地址
}


IFX_SSW_INLINE void Ifx_Ssw_jumpBackToLink(void)
{
    __asm("ji a11");  // 返回到链接寄存器a11存储的地址
}

IFX_SSW_INLINE void Ifx_Ssw_infiniteLoop(void)
{
    __asm("x: loopu\t x");  // 产生一个无条件的无限循环
}

IFX_SSW_INLINE void Ifx_Ssw_C_InitInline(void)
{
    extern void _c_init(void);
    _c_init();  // 启动代码或汇编代码中直接调用C环境初始化流程, 由编译器提供
}


#endif /* IFX_SSW_COMPILERSTASKING_H_ */
